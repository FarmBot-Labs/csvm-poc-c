/**

This File was autogenerated based off CeleryScript corpus: 20180209

It Should not be modified directly. It should be generated by running
    mix corpus /path/to/corpus.json

This file has two usable functions:

    celery_node_kind_name_t node_name_from_string(char *key)
      Lookup a node name by its string value.

    celery_arg_kind_name_t arg_name_from_string(char *key)
      Lookup a arg name by its string value.

*/

#ifndef CORPUS_H
#define CORPUS_H

#define NUMBER_NODE_NAMES (49)
#define NUMBER_ARG_NAMES (34)
#define BADKEY -1

#include <string.h>

/** Symbol of key => value */
typedef struct {
  char *key;
  int val;
} celery_kv_sym_t;

/* Begin Celery Node definition */
typedef enum CeleryNodeKind {
  NAMED_PIN,
	NOTHING,
	TOOL,
	COORDINATE,
	MOVE_ABSOLUTE,
	MOVE_RELATIVE,
	WRITE_PIN,
	READ_PIN,
	CHANNEL,
	WAIT,
	SEND_MESSAGE,
	EXECUTE,
	_IF,
	SEQUENCE,
	HOME,
	FIND_HOME,
	ZERO,
	EMERGENCY_LOCK,
	EMERGENCY_UNLOCK,
	READ_STATUS,
	SYNC,
	CHECK_UPDATES,
	POWER_OFF,
	REBOOT,
	TOGGLE_PIN,
	EXPLANATION,
	RPC_REQUEST,
	RPC_OK,
	RPC_ERROR,
	CALIBRATE,
	PAIR,
	REGISTER_GPIO,
	UNREGISTER_GPIO,
	CONFIG_UPDATE,
	FACTORY_RESET,
	EXECUTE_SCRIPT,
	SET_USER_ENV,
	TAKE_PHOTO,
	POINT,
	INSTALL_FARMWARE,
	UPDATE_FARMWARE,
	REMOVE_FARMWARE,
	SCOPE_DECLARATION,
	IDENTIFIER,
	VARIABLE_DECLARATION,
	PARAMETER_DECLARATION,
	SET_SERVO_ANGLE,
	CHANGE_OWNERSHIP,
	INSTALL_FIRST_PARTY_FARMWARE
} celery_node_kind_name_t;

/** Lookup table for the `node_name_from_string()` function. */
static celery_kv_sym_t node_name_lookup_table[] = {
  {"named_pin", NAMED_PIN},
	{"nothing", NOTHING},
	{"tool", TOOL},
	{"coordinate", COORDINATE},
	{"move_absolute", MOVE_ABSOLUTE},
	{"move_relative", MOVE_RELATIVE},
	{"write_pin", WRITE_PIN},
	{"read_pin", READ_PIN},
	{"channel", CHANNEL},
	{"wait", WAIT},
	{"send_message", SEND_MESSAGE},
	{"execute", EXECUTE},
	{"_if", _IF},
	{"sequence", SEQUENCE},
	{"home", HOME},
	{"find_home", FIND_HOME},
	{"zero", ZERO},
	{"emergency_lock", EMERGENCY_LOCK},
	{"emergency_unlock", EMERGENCY_UNLOCK},
	{"read_status", READ_STATUS},
	{"sync", SYNC},
	{"check_updates", CHECK_UPDATES},
	{"power_off", POWER_OFF},
	{"reboot", REBOOT},
	{"toggle_pin", TOGGLE_PIN},
	{"explanation", EXPLANATION},
	{"rpc_request", RPC_REQUEST},
	{"rpc_ok", RPC_OK},
	{"rpc_error", RPC_ERROR},
	{"calibrate", CALIBRATE},
	{"pair", PAIR},
	{"register_gpio", REGISTER_GPIO},
	{"unregister_gpio", UNREGISTER_GPIO},
	{"config_update", CONFIG_UPDATE},
	{"factory_reset", FACTORY_RESET},
	{"execute_script", EXECUTE_SCRIPT},
	{"set_user_env", SET_USER_ENV},
	{"take_photo", TAKE_PHOTO},
	{"point", POINT},
	{"install_farmware", INSTALL_FARMWARE},
	{"update_farmware", UPDATE_FARMWARE},
	{"remove_farmware", REMOVE_FARMWARE},
	{"scope_declaration", SCOPE_DECLARATION},
	{"identifier", IDENTIFIER},
	{"variable_declaration", VARIABLE_DECLARATION},
	{"parameter_declaration", PARAMETER_DECLARATION},
	{"set_servo_angle", SET_SERVO_ANGLE},
	{"change_ownership", CHANGE_OWNERSHIP},
	{"install_first_party_farmware", INSTALL_FIRST_PARTY_FARMWARE}
};

/** Looks up a Node name by it's string value */
celery_node_kind_name_t node_name_from_string(char *key) {
    for (int i=0; i < NUMBER_NODE_NAMES; i++) {
      celery_kv_sym_t *sym = node_name_lookup_table + i*sizeof(celery_kv_sym_t);
      if (strcmp(sym->key, key) == 0)
        return sym->val;
    }
    return BADKEY;
}

/* Begin Celery Arg definition */
typedef enum CeleryArgKind {
  _ELSE,
	_THEN,
	LOCALS,
	OFFSET,
	PIN_NUMBER,
	DATA_VALUE,
	LOCATION,
	LABEL,
	MILLISECONDS,
	PACKAGE,
	PIN_VALUE,
	RADIUS,
	RHS,
	URL,
	VALUE,
	VERSION,
	X,
	Y,
	Z,
	PIN_ID,
	PIN_TYPE,
	POINTER_ID,
	POINTER_TYPE,
	PIN_MODE,
	SEQUENCE_ID,
	LHS,
	OP,
	CHANNEL_NAME,
	MESSAGE_TYPE,
	TOOL_ID,
	AXIS,
	MESSAGE,
	SPEED,
	DATA_TYPE
} celery_arg_kind_name_t;

/** Lookup table for the `arg_name_from_string()` function. */
static celery_kv_sym_t arg_name_lookup_table[] = {
  {"_else", _ELSE},
	{"_then", _THEN},
	{"locals", LOCALS},
	{"offset", OFFSET},
	{"pin_number", PIN_NUMBER},
	{"data_value", DATA_VALUE},
	{"location", LOCATION},
	{"label", LABEL},
	{"milliseconds", MILLISECONDS},
	{"package", PACKAGE},
	{"pin_value", PIN_VALUE},
	{"radius", RADIUS},
	{"rhs", RHS},
	{"url", URL},
	{"value", VALUE},
	{"version", VERSION},
	{"x", X},
	{"y", Y},
	{"z", Z},
	{"pin_id", PIN_ID},
	{"pin_type", PIN_TYPE},
	{"pointer_id", POINTER_ID},
	{"pointer_type", POINTER_TYPE},
	{"pin_mode", PIN_MODE},
	{"sequence_id", SEQUENCE_ID},
	{"lhs", LHS},
	{"op", OP},
	{"channel_name", CHANNEL_NAME},
	{"message_type", MESSAGE_TYPE},
	{"tool_id", TOOL_ID},
	{"axis", AXIS},
	{"message", MESSAGE},
	{"speed", SPEED},
	{"data_type", DATA_TYPE}
};

/** Looks up a Arg name by it's string value */
celery_arg_kind_name_t arg_name_from_string(char *key) {
    for (int i=0; i < NUMBER_NODE_NAMES; i++) {
      celery_kv_sym_t *sym = arg_name_lookup_table + i*sizeof(celery_kv_sym_t);
      if (strcmp(sym->key, key) == 0)
        return sym->val;
    }
    return BADKEY;
}

#endif
