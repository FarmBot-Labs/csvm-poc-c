/**

This File was autogenerated based off CeleryScript corpus: 20180209

It Should not be modified directly. It should be generated by running
    mix corpus /path/to/corpus.json

This file has two usable functions:

    celery_node_kind_name_t node_name_from_string(char *key)
      Lookup a node name by its string value.

    celery_arg_kind_name_t arg_name_from_string(char *key)
      Lookup a arg name by its string value.

*/


#include "corpus.h"
#include <string.h>

/** Lookup table for the `node_name_from_string()` function. */
static celery_kv_sym_t node_name_lookup_table[] = {
  {"named_pin", NAMED_PIN},
	{"nothing", NOTHING},
	{"tool", TOOL},
	{"coordinate", COORDINATE},
	{"move_absolute", MOVE_ABSOLUTE},
	{"move_relative", MOVE_RELATIVE},
	{"write_pin", WRITE_PIN},
	{"read_pin", READ_PIN},
	{"channel", CHANNEL},
	{"wait", WAIT},
	{"send_message", SEND_MESSAGE},
	{"execute", EXECUTE},
	{"if", IF},
	{"sequence", SEQUENCE},
	{"home", HOME},
	{"find_home", FIND_HOME},
	{"zero", ZERO},
	{"emergency_lock", EMERGENCY_LOCK},
	{"emergency_unlock", EMERGENCY_UNLOCK},
	{"read_status", READ_STATUS},
	{"sync", SYNC},
	{"check_updates", CHECK_UPDATES},
	{"power_off", POWER_OFF},
	{"reboot", REBOOT},
	{"toggle_pin", TOGGLE_PIN},
	{"explanation", EXPLANATION},
	{"rpc_request", RPC_REQUEST},
	{"rpc_ok", RPC_OK},
	{"rpc_error", RPC_ERROR},
	{"calibrate", CALIBRATE},
	{"pair", PAIR},
	{"register_gpio", REGISTER_GPIO},
	{"unregister_gpio", UNREGISTER_GPIO},
	{"config_update", CONFIG_UPDATE},
	{"factory_reset", FACTORY_RESET},
	{"execute_script", EXECUTE_SCRIPT},
	{"set_user_env", SET_USER_ENV},
	{"take_photo", TAKE_PHOTO},
	{"point", POINT},
	{"install_farmware", INSTALL_FARMWARE},
	{"update_farmware", UPDATE_FARMWARE},
	{"remove_farmware", REMOVE_FARMWARE},
	{"scope_declaration", SCOPE_DECLARATION},
	{"identifier", IDENTIFIER},
	{"variable_declaration", VARIABLE_DECLARATION},
	{"parameter_declaration", PARAMETER_DECLARATION},
	{"set_servo_angle", SET_SERVO_ANGLE},
	{"change_ownership", CHANGE_OWNERSHIP},
	{"install_first_party_farmware", INSTALL_FIRST_PARTY_FARMWARE}
};

/** Lookup table for the `arg_name_from_string()` function. */
static celery_kv_sym_t arg_name_lookup_table[] = {
  {"else", ELSE},
	{"then", THEN},
	{"locals", LOCALS},
	{"offset", OFFSET},
	{"pin_number", PIN_NUMBER},
	{"data_value", DATA_VALUE},
	{"location", LOCATION},
	{"label", LABEL},
	{"milliseconds", MILLISECONDS},
	{"package", PACKAGE},
	{"pin_value", PIN_VALUE},
	{"radius", RADIUS},
	{"rhs", RHS},
	{"url", URL},
	{"value", VALUE},
	{"version", VERSION},
	{"x", X},
	{"y", Y},
	{"z", Z},
	{"pin_id", PIN_ID},
	{"pin_type", PIN_TYPE},
	{"pointer_id", POINTER_ID},
	{"pointer_type", POINTER_TYPE},
	{"pin_mode", PIN_MODE},
	{"sequence_id", SEQUENCE_ID},
	{"lhs", LHS},
	{"op", OP},
	{"channel_name", CHANNEL_NAME},
	{"message_type", MESSAGE_TYPE},
	{"tool_id", TOOL_ID},
	{"axis", AXIS},
	{"message", MESSAGE},
	{"speed", SPEED},
	{"data_type", DATA_TYPE}
};

/** Looks up a Node name by it's string value */
celery_node_kind_name_t node_name_from_string(char *key) {
    for (int i=0; i < NUMBER_NODE_NAMES; i++) {
        celery_kv_sym_t *sym = node_name_lookup_table + i;
        if (strcmp(sym->key, key) == 0)
            return sym->val;
    }
    return BADKEY;
}

char* string_from_node_name(celery_node_kind_name_t name) {
    for (int i=0; i < NUMBER_NODE_NAMES; i++) {
        celery_kv_sym_t *sym = node_name_lookup_table + i;
        if(sym->val == name)
            return sym->key;
    }
    return NULL;
}

/** Looks up a Arg name by it's string value */
celery_arg_kind_name_t arg_name_from_string(char *key) {
    for (int i=0; i < NUMBER_ARG_NAMES; i++) {
        celery_kv_sym_t *sym = arg_name_lookup_table + i;
        if (strcmp(sym->key, key) == 0)
            return sym->val;
    }
    return BADKEY;
}

char* string_from_arg_name(celery_arg_kind_name_t name) {
    for (int i=0; i < NUMBER_ARG_NAMES; i++) {
        celery_kv_sym_t *sym = arg_name_lookup_table + i;
        if(sym->val == name)
            return sym->key;
    }
    return NULL;
}
